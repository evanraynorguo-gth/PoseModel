<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pose Shooting Game</title>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.3.1/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@teachablemachine/pose@0.8/dist/teachablemachine-pose.min.js"></script>
<style>
  body { margin:0; font-family: Arial; background:linear-gradient(135deg,#74ebd5,#ACB6E5); display:flex; flex-direction:column; align-items:center;}
  #main { display:flex; gap:20px; margin-top:20px;}
  canvas { border-radius:10px; box-shadow:0 5px 20px rgba(0,0,0,0.3);}
  #label-container { margin-top:10px; display:flex; gap:15px; flex-wrap: wrap;}
  .label { font-size:20px; font-weight:bold; padding:5px 10px; border-radius:8px; text-shadow:1px 1px 3px rgba(0,0,0,0.7); transition: transform 0.3s, box-shadow 0.3s;}
  .active { transform: scale(1.2); box-shadow:0 0 15px #fff,0 0 25px #fff,0 0 35px #ff0;}
  #score { margin-top:10px; font-size:20px; font-weight:bold; }
  #winOverlay {
    position:absolute; top:0; left:0; width:100%; height:100%;
    background: rgba(0,0,0,0.7); color:#fff; font-size:36px;
    display:flex; flex-direction:column; justify-content:center; align-items:center;
    text-align:center; opacity:0; pointer-events:none; transition:opacity 2s;
  }
  #winOverlay button {
    margin-top:20px; font-size:24px; padding:10px 20px;
    border:none; border-radius:8px; cursor:pointer; background:#FFD700; color:#000;
  }
</style>
</head>
<body>

<div id="controls">
  <button onclick="start()">Start</button>
</div>

<div id="main">
  <canvas id="canvas" width="400" height="400"></canvas>
  <canvas id="gameCanvas" width="400" height="400" style="background:ivory;"></canvas>
</div>

<div id="label-container"></div>
<div id="score">Score: 0 | Attempts: 0</div>

<div id="winOverlay">
  <div>ðŸŽ‰ You Win! ðŸŽ‰</div>
  <div id="finalStats"></div>
  <button onclick="restartGame()">Play Again</button>
</div>

<script>
const URL = "./my_model/";
let model, webcam, ctx, labelContainer, maxPredictions, loopId;
let latestClass="Wait", latestPose=null;

// Map classes
const classMap = {"Class 1":"Right","Class 2":"Left","Class 3":"Shoot","Class 4":"Wait"};
const classColors = {Right:"#FF4C4C", Left:"#4C9EFF", Shoot:"#FFD24C", Wait:"#7CFF4C"};

// Game setup
const gameCanvas = document.getElementById("gameCanvas");
const gameCtx = gameCanvas.getContext("2d");
let ball = { x:200, y:350, radius:20, angle:-Math.PI/2, vx:0, vy:0, shooting:false };
let goal = { x:150, y:50, width:100, height:50, vx:2, flash:0 };
let score=0, attempts=0, win=false;
const baseSpeed=5;
let particles=[];

// --- Start webcam and model ---
async function start(){
    const modelURL = URL+"model.json";
    const metadataURL = URL+"metadata.json";
    model = await tmPose.load(modelURL,metadataURL);
    maxPredictions = model.getTotalClasses();

    webcam = new tmPose.Webcam(400,400,true);
    await webcam.setup();
    await webcam.play();

    const canvasEl = document.getElementById("canvas");
    ctx = canvasEl.getContext("2d");

    labelContainer = document.getElementById("label-container");
    labelContainer.innerHTML="";
    for(let i=0;i<maxPredictions;i++){
        const div=document.createElement("div");
        div.classList.add("label");
        labelContainer.appendChild(div);
    }

    loopId=requestAnimationFrame(loop);
    requestAnimationFrame(gameLoop);
}

// --- Webcam loop ---
async function loop(){
    webcam.update();
    ctx.clearRect(0,0,400,400);
    ctx.drawImage(webcam.canvas,0,0);
    await predict();
    drawPose(latestPose);
    loopId=requestAnimationFrame(loop);
}

// --- Pose prediction ---
async function predict(){
    const {pose,posenetOutput} = await model.estimatePose(webcam.canvas);
    const prediction = await model.predict(posenetOutput);
    latestPose=pose;

    let maxProb=0,activeIndex=0;
    for(let i=0;i<maxPredictions;i++){
        if(prediction[i].probability>maxProb){ maxProb=prediction[i].probability; activeIndex=i; }
    }

    for(let i=0;i<maxPredictions;i++){
        const mapped=classMap[prediction[i].className]||prediction[i].className;
        const div=labelContainer.childNodes[i];
        div.innerHTML=`${mapped}: ${(prediction[i].probability*100).toFixed(1)}%`;
        div.style.backgroundColor=classColors[mapped]||"#ffffffaa";
        div.style.color="#000";
        if(i===activeIndex) div.classList.add("active"); else div.classList.remove("active");
    }

    latestClass=classMap[prediction[activeIndex].className]||"Wait";
}

// --- Draw skeleton ---
function drawPose(pose){
    if(!pose) return;
    const minPartConfidence=0.5;
    tmPose.drawKeypoints(pose.keypoints,minPartConfidence,ctx);
    tmPose.drawSkeleton(pose.keypoints,minPartConfidence,ctx);
}

// --- Spawn particles ---
function spawnParticles(x,y,multiple=10){
    for(let i=0;i<multiple;i++){
        particles.push({
            x:x, y:y,
            vx:(Math.random()-0.5)*4,
            vy:(Math.random()-0.5)*4,
            alpha:1,
            color:["#FFD700","#32CD32","#FF69B4","#FFA500","#1E90FF"][Math.floor(Math.random()*5)]
        });
    }
}

// --- Game loop ---
function gameLoop(){
    gameCtx.clearRect(0,0,400,400);

    // Move goal
    goal.x += goal.vx;
    if(goal.x<=0||goal.x+goal.width>=400) goal.vx*=-1;

    // Draw goal with flash
    gameCtx.fillStyle=goal.flash>0?"yellow":"green";
    if(goal.flash>0) goal.flash--;
    gameCtx.fillRect(goal.x,goal.y,goal.width,goal.height);

    // Rotate ball
    if(!ball.shooting){
        const rotationSpeed=0.02;
        if(latestClass==="Left") ball.angle-=rotationSpeed;
        else if(latestClass==="Right") ball.angle+=rotationSpeed;
    }

    // Shoot
    if(latestClass==="Shoot" && !ball.shooting){
        ball.shooting=true;
        attempts++;
        let speedFactor = (attempts %2===1)?0.5:1.5; // Odd:50%, Even:150%
        const shootSpeed=baseSpeed*speedFactor;
        ball.vx=Math.cos(ball.angle)*shootSpeed;
        ball.vy=Math.sin(ball.angle)*shootSpeed;
    }

    // Update ball
    if(ball.shooting){
        ball.x+=ball.vx;
        ball.y+=ball.vy;

        // Check goal
        if(ball.x>goal.x && ball.x<goal.x+goal.width && ball.y>goal.y && ball.y<goal.y+goal.height){
            score++;
            document.getElementById("score").innerText=`Score: ${score} | Attempts: ${attempts}`;
            resetBall();
            goal.flash=10;
            spawnParticles(ball.x,ball.y,30); // more particles for visibility
        }
        else if(ball.x<0||ball.x>400||ball.y<0||ball.y>400){
            score--;
            if(score<0) score=0;
            document.getElementById("score").innerText=`Score: ${score} | Attempts: ${attempts}`;
            resetBall();
        }
    }

    // Draw ball + arrow
    gameCtx.save();
    gameCtx.translate(ball.x,ball.y);
    gameCtx.rotate(ball.angle);
    gameCtx.fillStyle="blue";
    gameCtx.beginPath();
    gameCtx.arc(0,0,ball.radius,0,2*Math.PI);
    gameCtx.fill();
    gameCtx.strokeStyle="white";
    gameCtx.lineWidth=3;
    gameCtx.beginPath();
    gameCtx.moveTo(0,0);
    gameCtx.lineTo(ball.radius,0);
    gameCtx.stroke();
    gameCtx.restore();

    // Draw particles
    particles.forEach((p,i)=>{
        gameCtx.fillStyle=`rgba(${parseInt(p.color.slice(1,3),16)},${parseInt(p.color.slice(3,5),16)},${parseInt(p.color.slice(5,7),16)},${p.alpha})`;
        gameCtx.beginPath();
        gameCtx.arc(p.x,p.y,3,0,Math.PI*2);
        gameCtx.fill();
        p.x+=p.vx; p.y+=p.vy; p.alpha-=0.05;
        if(p.alpha<=0) particles.splice(i,1);
    });

    // Win condition
    if(score>=5 && !win){
        win=true;
        const overlay=document.getElementById("winOverlay");
        overlay.style.pointerEvents="auto";
        overlay.style.opacity=1;
        document.getElementById("finalStats").innerText=`Final Score: ${score}\nTotal Attempts: ${attempts}`;
        for(let i=0;i<4;i++){ setTimeout(()=>spawnParticles(200,200,50), i*500); } // bigger confetti
    }

    requestAnimationFrame(gameLoop);
}

function resetBall(){
    ball.x=200; ball.y=350; ball.angle=-Math.PI/2; ball.vx=0; ball.vy=0; ball.shooting=false;
}

function restartGame(){
    const overlay=document.getElementById("winOverlay");
    overlay.style.opacity=0;
    setTimeout(()=>{
        overlay.style.pointerEvents="none";
        score=0; attempts=0; win=false;
        resetBall(); particles=[];
        document.getElementById("score").innerText=`Score: ${score} | Attempts: ${attempts}`;
    },2000);
}
</script>
</body>
</html>
